import express from 'express'
import cors from 'cors'
import multer from 'multer'
import path from 'path'
import fs from 'fs'
import sqlite3 from 'sqlite3'
import { open } from 'sqlite'
import 'dotenv/config'
import jwt from 'jsonwebtoken'
import bcrypt from 'bcryptjs'
import PDFDocument from 'pdfkit'
import nodemailer from 'nodemailer'
import twilio from 'twilio'

const app = express()
app.use(cors())
app.use(express.json())

// --- Paths & storage
const ROOT = process.cwd()
const DB_PATH = path.join(ROOT, 'inventory-server', 'database', 'lagerpro.db')
const UPLOAD_DIR = path.join(ROOT, 'inventory-server', 'uploads')
fs.mkdirSync(UPLOAD_DIR, { recursive: true })
app.use('/uploads', express.static(UPLOAD_DIR))
const upload = multer({ dest: UPLOAD_DIR })

// --- DB open
const db = await open({ filename: DB_PATH, driver: sqlite3.Database })

// --- Integrations
const smsEnabled = !!(process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN && process.env.TWILIO_FROM)
const twilioClient = smsEnabled ? twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN) : null

const emailEnabled = !!(process.env.SMTP_HOST && process.env.SMTP_USER && process.env.SMTP_PASS)
const transporter = emailEnabled ? nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: Number(process.env.SMTP_PORT || 587),
  secure: String(process.env.SMTP_SECURE || 'false') === 'true',
  auth: { user: process.env.SMTP_USER, pass: process.env.SMTP_PASS }
}) : null

// --- Schema & seed
async function migrate(){
  await db.exec(`
    PRAGMA foreign_keys = ON;
    CREATE TABLE IF NOT EXISTS users (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      username TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      role TEXT NOT NULL DEFAULT 'admin'
    );
    CREATE TABLE IF NOT EXISTS locations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT UNIQUE NOT NULL
    );
    CREATE TABLE IF NOT EXISTS alert_numbers (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      phone TEXT UNIQUE NOT NULL
    );
    CREATE TABLE IF NOT EXISTS products (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      qty INTEGER NOT NULL DEFAULT 0,
      unit TEXT NOT NULL DEFAULT 'stk',
      price_per_unit REAL,
      total_cost REAL,
      alert_threshold INTEGER NOT NULL DEFAULT 5,
      image_url TEXT,
      location_id INTEGER REFERENCES locations(id) ON DELETE SET NULL,
      rack TEXT,
      shelf TEXT,
      updated_at TEXT DEFAULT CURRENT_TIMESTAMP
    );
    CREATE TABLE IF NOT EXISTS tools (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      serial TEXT,
      condition TEXT DEFAULT 'OK',
      owner TEXT,
      price REAL,
      purchased_at TEXT,
      location_id INTEGER REFERENCES locations(id) ON DELETE SET NULL,
      updated_at TEXT DEFAULT CURRENT_TIMESTAMP
    );
    CREATE TABLE IF NOT EXISTS transfers (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      kind TEXT NOT NULL, -- product/tool
      ref_id INTEGER,
      from_location_id INTEGER,
      to_location_id INTEGER,
      qty INTEGER,
      note TEXT,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );
    CREATE TABLE IF NOT EXISTS projects (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      name TEXT NOT NULL,
      client TEXT,
      address TEXT,
      status TEXT DEFAULT 'Planlagt',
      budget REAL,
      created_at TEXT DEFAULT CURRENT_TIMESTAMP
    );
    CREATE TABLE IF NOT EXISTS project_materials (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_id INTEGER REFERENCES projects(id) ON DELETE CASCADE,
      name TEXT NOT NULL,
      qty REAL NOT NULL,
      unit TEXT NOT NULL DEFAULT 'stk',
      price_per_unit REAL,
      note TEXT
    );
    CREATE TABLE IF NOT EXISTS project_tools (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_id INTEGER REFERENCES projects(id) ON DELETE CASCADE,
      tool_id INTEGER REFERENCES tools(id) ON DELETE SET NULL
    );
    CREATE TABLE IF NOT EXISTS project_orders (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      project_id INTEGER REFERENCES projects(id) ON DELETE CASCADE,
      supplier TEXT,
      item TEXT,
      qty REAL,
      unit TEXT DEFAULT 'stk',
      unit_price REAL,
      total_price REAL,
      ordered_at TEXT DEFAULT CURRENT_TIMESTAMP
    );
  `)

  const adminU = process.env.ADMIN_USER || 'admin'
  const adminP = process.env.ADMIN_PASS || 'lagerpro123'
  const has = await db.get('SELECT * FROM users WHERE username=?',[adminU])
  if (!has) await db.run('INSERT INTO users (username,password,role) VALUES (?,?,?)',[adminU, adminP, 'admin'])

  for (const name of ['Hovedlager','Bil 1','Bil 2','Bil 3','Lager 2']){
    const r = await db.get('SELECT id FROM locations WHERE name=?',[name])
    if (!r) await db.run('INSERT INTO locations (name) VALUES (?)',[name])
  }

  const defaultPhone = '+47 47510880'
  const exists = await db.get('SELECT id FROM alert_numbers WHERE phone=?',[defaultPhone])
  if (!exists) await db.run('INSERT INTO alert_numbers (phone) VALUES (?)',[defaultPhone])
}
await migrate()

// --- Auth & roles
function signUser(u){
  return jwt.sign({ id:u.id, username:u.username, role:u.role }, process.env.JWT_SECRET || 'devsecret', { expiresIn:'12h' })
}
function requireAuth(req,res,next){
  const t = (req.headers.authorization||'').replace('Bearer ','')
  if(!t) return res.status(401).json({error:'Mangler token'})
  try{ req.user = jwt.verify(t, process.env.JWT_SECRET || 'devsecret'); next() }
  catch{ return res.status(401).json({error:'Ugyldig/utlÃ¸pt token'}) }
}
function requireAdmin(req,res,next){
  if(req.user?.role!=='admin') return res.status(403).json({error:'Kun for admin'})
  next()
}

// --- Routes: auth
app.post('/api/login', async (req,res)=>{
  const { username, password } = req.body
  const u = await db.get('SELECT * FROM users WHERE username=?',[username])
  if (!u) return res.status(401).json({error:'Feil brukernavn/passord'})
  const hashed = u.password.startsWith('$2')
  let ok=false
  if (hashed) ok = await bcrypt.compare(password, u.password)
  else { ok = (password===u.password); if(ok){ const h=await bcrypt.hash(password,10); await db.run('UPDATE users SET password=? WHERE id=?',[h,u.id]) } }
  if (!ok) return res.status(401).json({error:'Feil brukernavn/passord'})
  res.json({ token: signUser(u), user:{id:u.id,username:u.username,role:u.role} })
})

// Admin: hash alle klartekstpassord
app.post('/api/users/hash_all', requireAuth, requireAdmin, async (req,res)=>{
  const users = await db.all('SELECT * FROM users')
  let changed=0
  for (const u of users){
    if (!u.password.startsWith('$2')){
      const h = await bcrypt.hash(u.password,10)
      await db.run('UPDATE users SET password=? WHERE id=?',[h,u.id])
      changed++
    }
  }
  res.json({ok:true, changed})
})

// --- Helpers
async function sendLowStockSMS(product, locationName){
  if (!smsEnabled) return
  const nums = await db.all('SELECT phone FROM alert_numbers')
  const text = `LagerPro: Lav beholdning '${product.name}' i ${locationName}. Antall igjen: ${product.qty}.`
  await Promise.all(nums.map(n => twilioClient.messages.create({ body:text, from: process.env.TWILIO_FROM, to: n.phone.replace(/\s+/g,'') })))
}
async function sendEmail(subject, text, attachments=[]){
  if (!emailEnabled) return { ok:false, error:'E-post ikke satt opp' }
  const info = await transporter.sendMail({ from: process.env.EMAIL_FROM, to: process.env.EMAIL_TO, subject, text, attachments })
  return { ok:true, messageId: info.messageId }
}

// --- Inventory (lesing for alle innloggede, skriving kun admin)
app.get('/api/locations', requireAuth, async (req,res)=>{
  res.json(await db.all('SELECT * FROM locations ORDER BY name'))
})
app.get('/api/products', requireAuth, async (req,res)=>{
  const rows = await db.all(`SELECT p.*, l.name as location_name FROM products p LEFT JOIN locations l ON p.location_id=l.id ORDER BY updated_at DESC`)
  res.json(rows)
})
app.post('/api/products', requireAuth, requireAdmin, upload.single('image'), async (req,res)=>{
  const { name, qty, unit, alert_threshold, location_id, rack, shelf, price_per_unit, total_cost } = req.body
  if (!name) return res.status(400).json({ error:'Navn mangler' })
  const q = Number(qty||0)
  let ppu = price_per_unit!=null? Number(price_per_unit): null
  let tot = total_cost!=null? Number(total_cost): null
  if (ppu!=null && q>0) tot = ppu*q
  if (ppu==null && tot!=null && q>0) ppu = tot/q
  let image_url = null
  if (req.file) image_url = '/uploads/'+req.file.filename
  const r = await db.run('INSERT INTO products (name,qty,unit,price_per_unit,total_cost,alert_threshold,image_url,location_id,rack,shelf) VALUES (?,?,?,?,?,?,?,?,?,?)',
    [name, q, unit||'stk', ppu, tot, Number(alert_threshold||5), image_url, location_id||null, rack||null, shelf||null])
  const p = await db.get('SELECT p.*, l.name as location_name FROM products p LEFT JOIN locations l ON p.location_id=l.id WHERE p.id=?',[r.lastID])
  if (p.qty <= p.alert_threshold) await sendLowStockSMS(p, p.location_name||'Ukjent')
  res.json(p)
})
app.put('/api/products/:id', requireAuth, requireAdmin, upload.single('image'), async (req,res)=>{
  const id = req.params.id
  const old = await db.get('SELECT * FROM products WHERE id=?',[id])
  if (!old) return res.status(404).json({ error:'Ikke funnet' })
  const q = req.body.qty!==undefined? Number(req.body.qty) : old.qty
  let ppu = req.body.price_per_unit!=null? Number(req.body.price_per_unit): old.price_per_unit
  let tot = req.body.total_cost!=null? Number(req.body.total_cost): old.total_cost
  if (ppu!=null && q>0) tot = ppu*q
  else if (ppu==null && tot!=null && q>0) ppu = tot/q
  let image_url = old.image_url
  if (req.file) image_url = '/uploads/'+req.file.filename
  await db.run('UPDATE products SET name=?,qty=?,unit=?,price_per_unit=?,total_cost=?,alert_threshold=?,image_url=?,location_id=?,rack=?,shelf=?,updated_at=CURRENT_TIMESTAMP WHERE id=?',
    [req.body.name||old.name, q, req.body.unit||old.unit, ppu, tot, req.body.alert_threshold!==undefined? Number(req.body.alert_threshold): old.alert_threshold, image_url, req.body.location_id||old.location_id, req.body.rack??old.rack, req.body.shelf??old.shelf, id])
  const p = await db.get('SELECT p.*, l.name as location_name FROM products p LEFT JOIN locations l ON p.location_id=l.id WHERE p.id=?',[id])
  if (p.qty <= p.alert_threshold) await sendLowStockSMS(p, p.location_name||'Ukjent')
  res.json(p)
})

// --- Projects
app.get('/api/projects', requireAuth, async (req,res)=>{
  res.json(await db.all('SELECT * FROM projects ORDER BY created_at DESC'))
})
app.post('/api/projects', requireAuth, async (req,res)=>{
  const { name, client, address, status, budget } = req.body
  if (!name) return res.status(400).json({ error:'Prosjektnavn mangler' })
  const r = await db.run('INSERT INTO projects (name,client,address,status,budget) VALUES (?,?,?,?,?)',[name, client||null, address||null, status||'Planlagt', budget!=null?Number(budget):null])
  res.json({ id:r.lastID, name, client, address, status: status||'Planlagt', budget: budget!=null?Number(budget):null })
})

// Kalkulator -> lagre til prosjekt + trekk fra Hovedlager
app.post('/api/projects/:id/materials/bulk_save', requireAuth, async (req,res)=>{
  const project_id = Number(req.params.id)
  const { items } = req.body
  if (!Array.isArray(items) || !items.length) return res.status(400).json({ error:'Mangler materiallinjer' })
  const hoved = await db.get('SELECT id FROM locations WHERE name=?',['Hovedlager'])
  if (!hoved) return res.status(500).json({ error:'Hovedlager mangler' })
  const shortages=[]
  try{
    await db.run('BEGIN')
    for (const it of items){
      await db.run('INSERT INTO project_materials (project_id,name,qty,unit,price_per_unit,note) VALUES (?,?,?,?,?,?)',
        [project_id, it.name, Number(it.qty||0), it.unit||'stk', it.price_per_unit!=null?Number(it.price_per_unit):null, it.note||null])

      const p = await db.get('SELECT * FROM products WHERE name=? AND location_id=?',[it.name, hoved.id])
      const need = Number(it.qty||0)
      if (p && need>0){
        const newQty = p.qty - need
        await db.run('UPDATE products SET qty=? WHERE id=?',[Math.max(0,newQty), p.id])
        await db.run('INSERT INTO transfers (kind,ref_id,from_location_id,to_location_id,qty,note) VALUES (?,?,?,?,?,?)',
          ['product', p.id, hoved.id, null, need, 'Uttak til prosjekt '+project_id])
        if (newQty <= p.alert_threshold) await sendLowStockSMS({...p, qty:Math.max(0,newQty)}, 'Hovedlager')
        if (newQty < 0){
          shortages.push({ name: it.name, needed: need, had: p.qty, missing: Math.abs(newQty) })
        }
      } else {
        shortages.push({ name: it.name, needed: need, had: 0, missing: need })
      }
    }
    await db.run('COMMIT')
  }catch(e){
    await db.run('ROLLBACK')
    return res.status(500).json({ error:'Kunne ikke lagre materialer' })
  }
  res.json({ ok:true, shortages })
})

// Prosjektrapport (PDF) â nedlasting
app.get('/api/projects/:id/report/pdf', requireAuth, async (req,res)=>{
  const pr = await db.get('SELECT * FROM projects WHERE id=?',[req.params.id])
  if (!pr) return res.status(404).json({error:'Prosjekt ikke funnet'})
  const mats = await db.all('SELECT * FROM project_materials WHERE project_id=? ORDER BY id',[req.params.id])
  const ords = await db.all('SELECT * FROM project_orders WHERE project_id=? ORDER BY ordered_at DESC',[req.params.id])
  const tools = await db.all('SELECT t.* FROM project_tools pt LEFT JOIN tools t ON pt.tool_id=t.id WHERE pt.project_id=?',[req.params.id])
  const matsTotal = mats.reduce((s,m)=> s + (m.price_per_unit!=null? m.price_per_unit*m.qty : 0), 0)
  const ordsTotal = ords.reduce((s,o)=> s + (o.total_price||0), 0)

  res.setHeader('Content-Type','application/pdf')
  res.setHeader('Content-Disposition', `attachment; filename="prosjekt_${String(pr.name).replace(/\s+/g,'_')}.pdf"`)
  const doc = new PDFDocument({margin:50}); doc.pipe(res)
  doc.fontSize(18).text('LagerPro â Prosjektrapport', {align:'left'})
  doc.moveDown(0.5).fontSize(10).text(new Date().toLocaleString('no-NO')); doc.moveDown()
  doc.moveTo(50, doc.y).lineTo(545, doc.y).stroke(); doc.moveDown()
  doc.fontSize(12).text(`Prosjekt: ${pr.name}`); doc.text(`Kunde: ${pr.client||'-'}  â¢  Adresse: ${pr.address||'-'}  â¢  Status: ${pr.status}`); doc.moveDown()

  doc.fontSize(14).text('Materialer', {underline:true}); doc.fontSize(10)
  mats.forEach(m=> doc.text(`${m.name} â ${m.qty} ${m.unit} ${m.price_per_unit!=null? `Ã  ${m.price_per_unit} kr` : ''} ${m.note? 'â¢ '+m.note:''}`))
  doc.moveDown(0.5).fontSize(12).text(`Sum (kalkulert verdi): ${matsTotal.toFixed(2)} kr`)

  doc.moveDown().fontSize(14).text('Bestillinger', {underline:true}).fontSize(10)
  ords.forEach(o=> doc.text(`${o.supplier||'-'}: ${o.item||'-'} â ${o.qty} ${o.unit} Ã  ${o.unit_price||'-'} = ${o.total_price||'-'} kr`))
  doc.moveDown(0.5).fontSize(12).text(`Sum bestillinger: ${ordsTotal.toFixed(2)} kr`)

  doc.moveDown().fontSize(14).text('VerktÃ¸y', {underline:true}).fontSize(10)
  tools.forEach(t=> doc.text(`${t.name} (${t.serial||'â'}) â Tilstand: ${t.condition||'OK'}  Eier: ${t.owner||'â'}`))

  doc.end()
})

// Prosjektrapport â send e-post med vedlegg
app.post('/api/projects/:id/report/email', requireAuth, async (req,res)=>{
  const pr = await db.get('SELECT * FROM projects WHERE id=?',[req.params.id])
  if (!pr) return res.status(404).json({error:'Prosjekt ikke funnet'})
  const chunks=[]
  const doc = new PDFDocument({margin:50})
  doc.on('data', c=>chunks.push(c))
  doc.on('end', async ()=>{
    const buffer = Buffer.concat(chunks)
    const result = await sendEmail(`LagerPro â Prosjektrapport ${pr.name}`, `Se vedlagt rapport.`, [{ filename:`prosjekt_${pr.name}.pdf`, content: buffer }])
    if (!result.ok) return res.status(400).json({ error: result.error })
    res.json({ ok:true, messageId: result.messageId })
  })

  doc.fontSize(18).text('LagerPro â Prosjektrapport', {align:'left'})
  doc.moveDown(0.5).fontSize(10).text(new Date().toLocaleString('no-NO')); doc.moveDown()
  doc.moveTo(50, doc.y).lineTo(545, doc.y).stroke(); doc.moveDown()

  const mats = await db.all('SELECT * FROM project_materials WHERE project_id=? ORDER BY id',[req.params.id])
  const ords = await db.all('SELECT * FROM project_orders WHERE project_id=? ORDER BY ordered_at DESC',[req.params.id])
  const tools = await db.all('SELECT t.* FROM project_tools pt LEFT JOIN tools t ON pt.tool_id=t.id WHERE pt.project_id=?',[req.params.id])
  const matsTotal = mats.reduce((s,m)=> s + (m.price_per_unit!=null? m.price_per_unit*m.qty : 0), 0)
  const ordsTotal = ords.reduce((s,o)=> s + (o.total_price||0), 0)

  const prj = pr
  doc.fontSize(12).text(`Prosjekt: ${prj.name}`); doc.text(`Kunde: ${prj.client||'-'}  â¢  Adresse: ${prj.address||'-'}  â¢  Status: ${prj.status}`); doc.moveDown()
  doc.fontSize(14).text('Materialer', {underline:true}).fontSize(10)
  mats.forEach(m=> doc.text(`${m.name} â ${m.qty} ${m.unit} ${m.price_per_unit!=null? `Ã  ${m.price_per_unit} kr` : ''} ${m.note? 'â¢ '+m.note:''}`))
  doc.moveDown(0.5).fontSize(12).text(`Sum (kalkulert verdi): ${matsTotal.toFixed(2)} kr`)
  doc.moveDown().fontSize(14).text('Bestillinger', {underline:true}).fontSize(10)
  ords.forEach(o=> doc.text(`${o.supplier||'-'}: ${o.item||'-'} â ${o.qty} ${o.unit} Ã  ${o.unit_price||'-'} = ${o.total_price||'-'} kr`))
  doc.moveDown(0.5).fontSize(12).text(`Sum bestillinger: ${ordsTotal.toFixed(2)} kr`)
  doc.moveDown().fontSize(14).text('VerktÃ¸y', {underline:true}).fontSize(10)
  tools.forEach(t=> doc.text(`${t.name} (${t.serial||'â'}) â Tilstand: ${t.condition||'OK'}  Eier: ${t.owner||'â'}`))
  doc.end()
})

// --- DB backup (admin)
app.get('/api/db/export', requireAuth, requireAdmin, async (req,res)=>{
  res.setHeader('Content-Type','application/octet-stream')
  res.setHeader('Content-Disposition','attachment; filename="lagerpro.db"')
  fs.createReadStream(DB_PATH).pipe(res)
})
app.post('/api/db/import', requireAuth, requireAdmin, upload.single('file'), async (req,res)=>{
  if (!req.file) return res.status(400).json({error:'Mangler fil'})
  try{ fs.copyFileSync(req.file.path, DB_PATH); res.json({ok:true}) }
  catch{ res.status(500).json({error:'Kunne ikke skrive database'}) }
})

// --- Ping
app.get('/api/ping', (req,res)=> res.json({ok:true, version:'7.3', name: 'LagerPro v7.3 â Henrik Edition'}))

const PORT = process.env.PORT || 4000
app.listen(PORT, ()=> console.log('LagerPro v7.3 API pÃ¥ http://localhost:'+PORT))